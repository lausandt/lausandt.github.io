<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>Lau Sandt's thoughts on programming & wine - posts</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <link href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Lau Sandt's thoughts on programming & wine Atom Feed" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">Lau Sandt's thoughts on programming & wine</a></h1>
                <nav><ul>
                    <li><a href="/pages/about.html">about</a></li>
                    <li><a href="/pages/contact.html">contact</a></li>
                    <li class="active"><a href="/category/posts.html">posts</a></li>
                    <li><a href="/category/reviews.html">reviews</a></li>
                </ul></nav>
        </header><!-- /#banner -->

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="/mapping-functions-of-multiple-arguments.html">Mapping Functions of Multiple Arguments</a></h1>
<footer class="post-info">
        <abbr class="published" title="2024-08-27T00:00:00+02:00">
                Published: di 27 augustus 2024
        </abbr>
		<br />
        <abbr class="modified" title="2024-08-27T00:00:00+02:00">
                Updated: di 27 augustus 2024
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/lau-sandt.html">Lau Sandt</a>
        </address>
<p>In <a href="/category/posts.html">posts</a>.</p>

</footer><!-- /.post-info --><h2>Mapping Functions of Multiple Arguments</h2>
<p>Where the Functor is a generalisation of the map function. Generalised in the sense that it does not matter what the underlying structure is, as long as it is an instance of a functor, applying a function to that Functor will not change that underlying structure. In other words, fmap is a generalisation of map on the underlying structure.</p>
<p>An applicative functor is a further generalisation of the map function, but now we are not generalising on the underlying structure but on the type of function that our map function accepts as argument. The functorial map only accepts a function with a single argument (a -&gt; b). We can see this from the definition of fmap:</p>
<div class="highlight"><pre><span></span><code><span class="n">fmap</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">Functor</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span>
</code></pre></div>

<p>With a functorial map (fmap) we can do this: <code>fmap succ [1,2,3] = [2,3,4]</code></p>
<p>But we cannot do:</p>
<div class="highlight"><pre><span></span><code>x = [1,2,3,4,5]
y = [101,102,103,104,105]

fmap (fmap (+) x) y
</code></pre></div>

<p>Which is kind of odd when you think about partial function application in Haskell. I can do:</p>
<div class="highlight"><pre><span></span><code><span class="nv">fmap</span><span class="w"> </span><span class="ss">(</span><span class="o">+</span><span class="mi">1</span><span class="ss">)</span><span class="w"> </span>[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>]<span class="w"> </span>

<span class="nv">but</span><span class="w"> </span><span class="nv">I</span><span class="w"> </span><span class="nv">can</span><span class="err">&#39;t do</span>

<span class="err">amap [(+1),(+2),(+3)] [4,5,6] = [5,7,9]</span>
</code></pre></div>

<p>At least I can write the signature for this function:</p>
<p><code>amap :: [a -&gt; b] -&gt; [a] -&gt; [b]</code> </p>
<p>or more general</p>
<p><code>amap :: f (a -&gt; b) -&gt; f a -&gt; f b</code></p>
<p>But that solves only the first part of the problem; we still need to apply (+) to the list and get back a list of partially applied functions. Again, it helps to look at fmap and our amap functions. These are very similar:</p>
<div class="highlight"><pre><span></span><code><span class="n">fmap</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">Functor</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span>
<span class="n">amap</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">b</span>
</code></pre></div>

<p>We would just need to have a function that takes our (a -&gt; b) and wraps it with an f: <code>wrap :: Functor f =&gt; a -&gt; f a</code>. For instance, we want to wrap our partially applied function. But most important, we do not want to change our function. Say we want to wrap the number 42 in a Maybe, 42 should not change. <code>wrap 42 :: Maybe Int = Just 42</code></p>
<p>These are exactly the two functions of the Applicative Functor class that need to be implemented for any type to be an instance of the Applicative class.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="n">Functor</span> <span class="nb">f</span> =&gt; <span class="n">Applicative</span> <span class="nb">f</span> <span class="n">where</span>
  <span class="n">pure</span>  :: <span class="n">a</span> -&gt; <span class="nb">f</span> <span class="n">a</span>
  (<span class="s">&lt;*&gt;) :: f (a -&gt;</span> <span class="n">b</span>) -&gt; <span class="nb">f</span> <span class="n">a</span> -&gt; <span class="nb">f</span> <span class="n">b</span>
</code></pre></div>

<p>If I now run this GHCI <code>pure (+) &lt;*&gt; [1,2,3] &lt;*&gt; [4,5.6] = [5,7,9]</code> our problem is solved. Cool problem is solved, but what is the use case of this? </p>
<p>Say we want a function that maps a function that itself takes two arguments and has two lists of arguments as input.
1. A function that takes two arguments, for instance (+), we could make that generic by writing (a -&gt; b -&gt; c).
2. A list of similar types of arguments [a]
3. Another list of similar types of arguments [b]</p>
<p>To write a function like this is not that complicated.</p>
<div class="highlight"><pre><span></span><code><span class="n">lift2</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">[</span><span class="n">b</span><span class="o">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">[</span><span class="n">c</span><span class="o">]</span>
<span class="n">lift2</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="n">ys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">f x y | x &lt;- xs, y &lt;- ys</span><span class="o">]</span>
</code></pre></div>

<p>However, we can immediately see a problem with this. What if we want to apply a function with three arguments, four, or N arguments? We cannot write N functions to cover all possibilities, but given the Applicative we need not. We could rewrite the function above as. </p>
<div class="highlight"><pre><span></span><code><span class="n">lift2</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">[</span><span class="n">b</span><span class="o">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">[</span><span class="n">c</span><span class="o">]</span>
<span class="n">lift2</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="n">ys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pure</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">&lt;*&gt;</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">&lt;*&gt;</span><span class="w"> </span><span class="n">ys</span>
</code></pre></div>

<p>Now, if we want to lift a function with three arguments, we could simply write:</p>
<div class="highlight"><pre><span></span><code><span class="n">lift3</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">[</span><span class="n">b</span><span class="o">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">[</span><span class="n">c</span><span class="o">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">[</span><span class="n">d</span><span class="o">]</span>
<span class="n">lift3</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="n">ys</span><span class="w"> </span><span class="n">zs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pure</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">&lt;*&gt;</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">&lt;*&gt;</span><span class="w"> </span><span class="n">ys</span><span class="w"> </span><span class="o">&lt;*&gt;</span><span class="w"> </span><span class="n">zs</span><span class="w"> </span>
</code></pre></div>

<p>We have achieved our generalisation on the amount of arguments that a function takes. We have also preserved the generalisation on the structure by insisting that an Applicative instance is also a Functor instance. This is true, as we can see from the fact that we could implement fmap with our Applicative functions. </p>
<div class="highlight"><pre><span></span><code><span class="n">fmap</span><span class="s">&#39; :: Applicative a =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span>
<span class="s">fmap&#39;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pure</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">&lt;*&gt;</span><span class="w"> </span><span class="n">x</span>
</code></pre></div>

<p>so we can rewrite our lift function as </p>
<p>liftA2 :: Applicative f =&gt; (a -&gt; b) - f a -&gt; f b -&gt; f c
liftA2 f xs ys = pure f &lt;<em>&gt; xs &lt;</em>&gt; ys  </p>
<p>Which is exactly how the Applicative functor defines it. </p>
<p>I could now create a binary tree that is a member of the Applicative class.</p>
<div class="highlight"><pre><span></span><code>{-# LANGUAGE InstanceSigs #-}
module BinaryTree, where 

data Tree a = Leaf | Bin (Tree a) a (Tree a)
  deriving (Eq, Show) 

instance Functor Tree where
   fmap :: (a -&gt; b) -&gt; Tree a -&gt; Tree b
   fmap _ Leaf     = Leaf
   fmap f (Bin l x r) = Bin (fmap f l) (f x) (fmap f r)

instance Applicative Tree where
  pure x = Bin (pure x) x (pure x)
  (bin lf f rf) (&lt;*&gt;) (Bin lx x rx) = Bin (lf &lt;*&gt; lx ) (f x) (rf &lt;*&gt; rx)      
</code></pre></div>

<p>and apply functions to it; for instance, I can add two trees together.</p>
<div class="highlight"><pre><span></span><code>t1 = toTree [1..5]
t2 = toTree [6..10]
pure (+) &lt;*&gt; t1 &lt;*&gt; t2
Bin (Bin Leaf 9 (Bin Leaf 11 Leaf)) 7 (Bin Leaf 13 (Bin Leaf 15 Leaf))
</code></pre></div>

<p>The Applica­tive type­class has two func­tions pure and &lt;*&gt;. pure takes a type a and turns it into an Applica­tive (and a Func­tor). We can think of pure as turn­ing a into a default instance of the Applica­tive type­class.</p>
<p>if we would take a list and make it an instance of the Applicative class we have to implement pure. Implementing here to me means make sense of what the default instance of a list would be. The default instance of a list in my opinion can't be an empty list. If we think of a list, a list has elements, 1,2, ..., n. The empty list is a rarity, that wouldn't make it the default in my opinion. A list with elements has a default the list with one element.  </p>
<div class="highlight"><pre><span></span><code><span class="n">instance</span><span class="w"> </span><span class="n">Applicative</span><span class="w"> </span><span class="err">[]</span><span class="w"> </span><span class="k">where</span><span class="w"> </span>
<span class="w">  </span><span class="n">pure</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">x</span><span class="o">]</span>
</code></pre></div>

<p>Now we would have to consider how to implement an applicative map &lt;*&gt; so that it make sense. We want to map functions with multiple or no arguments. We want to map a list on a list basically </p>
<div class="highlight"><pre><span></span><code><span class="n">instance</span><span class="w"> </span><span class="n">Applicative</span><span class="w"> </span><span class="err">[]</span><span class="w"> </span><span class="k">where</span><span class="w"> </span>
<span class="w">  </span><span class="n">pure</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">x</span><span class="o">]</span>
<span class="w">  </span><span class="n">fs</span><span class="w"> </span><span class="o">&lt;*&gt;</span><span class="w"> </span><span class="n">gs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">f x  | f &lt;- fs, x &lt;- xs</span><span class="o">]</span>
</code></pre></div>                </article>
            </aside><!-- /#featured -->
                <section id="content" class="body">
                    <h1>Other articles</h1>
                    <hr />
                    <ol id="posts-list" class="hfeed">

            <li><article class="hentry">
                <header>
                    <h1><a href="/function-composition-a-deeper-look.html" rel="bookmark"
                           title="Permalink to Function composition a deeper look">Function composition a deeper look</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2024-08-07T00:00:00+02:00">
                Published: wo 07 augustus 2024
        </abbr>
		<br />
        <abbr class="modified" title="2024-08-07T00:00:00+02:00">
                Updated: wo 07 augustus 2024
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/lau-sandt.html">Lau Sandt</a>
        </address>
<p>In <a href="/category/posts.html">posts</a>.</p>

</footer><!-- /.post-info -->                <p>A look at how Category Theory underpins function composition.</p>
                <a class="readmore" href="/function-composition-a-deeper-look.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>
                </ol><!-- /#posts-list -->
                </section><!-- /#content -->
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="https://getpelican.com/">Pelican</a></li>
                            <li><a href="https://www.python.org/">Python.org</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>
                            <li><a href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                            <li><a href="https://github.com/lausandt">GitHub</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>